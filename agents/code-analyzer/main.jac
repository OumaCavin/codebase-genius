# Codebase Genius - Code Analyzer Agent
# Complete JAC implementation with Tree-sitter integration and CCG construction

import: py from tree_sitter;
import: py from pathlib;
import: py from typing;
import: py from datetime;
import: py from json;
import: py from collections;

# Code Element Node - Represents a function, class, or module
node code_element {
    has element_id: str;
    has element_type: str;  # 'function', 'class', 'method', 'module', 'variable'
    has name: str;
    has file_path: str;
    has start_line: int;
    has end_line: int;
    has language: str;
    has signature: str;
    has documentation: str;
    has complexity_score: float;
    has dependencies: list;
    has parameters: list;
    has return_type: str;
    has decorators: list;
    has visibility: str;  # 'public', 'private', 'protected'
    has is_async: bool;
    has is_deprecated: bool;
    has source_code: str;
}

# Relationship Edge - Represents connections between code elements
edge code_relationship {
    has relationship_type: str;  # 'calls', 'inherits', 'imports', 'contains', 'uses'
    has source_element: str;     # ID of source element
    has target_element: str;     # ID of target element
    has line_number: int;
    has context: str;            # Additional context about the relationship
    has confidence: float;       # Confidence score for the relationship
    has is_direct: bool;         # True if direct relationship, False if inherited
}

# File Analysis Node - Represents analysis of a single file
node file_analysis {
    has file_path: str;
    has language: str;
    has parsing_status: str;     # 'success', 'error', 'unsupported'
    has error_message: str;
    has elements_found: int;
    has relationships_found: int;
    has complexity_score: float;
    has lines_of_code: int;
    has parsed_at: datetime.datetime;
    has tree_sitter_tree: str;   # Serialized parse tree
}

# Module Node - Represents a module/package
node module {
    has module_name: str;
    has module_path: str;
    has is_package: bool;
    has imports: list;
    has exports: list;
    has dependencies: list;
    has level: int;  # Module level in hierarchy
    has parent_module: str;
    has submodules: list;
}

# Repository Analysis Node - Root node for CCG
node repository_analysis {
    has repository_path: str;
    has total_files_analyzed: int;
    has total_elements: int;
    has total_relationships: int;
    has analysis_timestamp: datetime.datetime;
    has supported_languages: list;
    has complexity_metrics: dict;
    has dependency_graph: dict;
    has documentation_coverage: float;
    has test_coverage: float;
}

# Main Code Analyzer Walker
walker analyze_repository {
    has repository_path: str;
    has max_file_size: int = 10485760;
    has include_ignored: bool = false;
    has analysis_depth: str = "full";  # 'basic', 'full', 'deep'
    
    # Initialize Tree-sitter language parsers
    can initialize_parsers with entry {
        try {
            import: py from tree_sitter;
            
            # Initialize language parsers
            language_parsers = {};
            
            # Python parser
            python_lang = tree_sitter.Language('tree-sitter-python', 'python');
            language_parsers['python'] = tree_sitter.Parser(python_lang);
            
            # JavaScript parser
            js_lang = tree_sitter.Language('tree-sitter-javascript', 'javascript');
            language_parsers['javascript'] = tree_sitter.Parser(js_lang);
            
            # TypeScript parser
            ts_lang = tree_sitter.Language('tree-sitter-typescript', 'typescript');
            language_parsers['typescript'] = tree_sitter.Parser(ts_lang);
            
            # Java parser
            java_lang = tree_sitter.Language('tree-sitter-java', 'java');
            language_parsers['java'] = tree_sitter.Parser(java_lang);
            
            # C++ parser
            cpp_lang = tree_sitter.Language('tree-sitter-cpp', 'cpp');
            language_parsers['cpp'] = tree_sitter.Parser(cpp_lang);
            
            # C parser
            c_lang = tree_sitter.Language('tree-sitter-c', 'c');
            language_parsers['c'] = tree_sitter.Parser(c_lang);
            
            report {
                "status": "success",
                "parsers_initialized": len(language_parsers),
                "supported_languages": list(language_parsers.keys())
            };
        }
        
        catch ImportError {
            report {
                "status": "warning",
                "message": "Tree-sitter not installed, using fallback parsing",
                "parsers_available": false
            };
            disengage;
        }
        
        catch Exception as e {
            report {
                "status": "error",
                "error": f"Parser initialization failed: {str(e)}"
            };
            disengage;
        }
    }
    
    # Parse a single file using Tree-sitter
    can parse_file with entry {
        try {
            import: py from tree_sitter;
            
            file_path = context_vars['file_path'];
            language = context_vars['language'];
            
            # Read file content
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                source_code = f.read();
            
            # Get appropriate parser
            parser = language_parsers[language];
            
            # Parse the code
            tree = parser.parse(source_code.encode());
            
            # Create file analysis node
            file_analysis_node = spawn file_analysis {
                file_path: file_path,
                language: language,
                parsing_status: "success",
                error_message: "",
                elements_found: 0,
                relationships_found: 0,
                complexity_score: 0.0,
                lines_of_code: len(source_code.splitlines()),
                parsed_at: datetime.datetime.now(),
                tree_sitter_tree: tree.root_node.sexp()
            };
            
            # Extract code elements
            elements = extract_code_elements(tree.root_node, language, file_path);
            relationships = extract_relationships(tree.root_node, language, file_path);
            
            # Update counts
            file_analysis_node.elements_found = len(elements);
            file_analysis_node.relationships_found = len(relationships);
            file_analysis_node.complexity_score = calculate_complexity_score(tree.root_node);
            
            # Create code element nodes
            element_nodes = [];
            for element in elements:
                element_node = spawn code_element {
                    element_id: element['id'],
                    element_type: element['type'],
                    name: element['name'],
                    file_path: file_path,
                    start_line: element['start_line'],
                    end_line: element['end_line'],
                    language: language,
                    signature: element['signature'],
                    documentation: element['documentation'],
                    complexity_score: element['complexity'],
                    dependencies: element['dependencies'],
                    parameters: element['parameters'],
                    return_type: element['return_type'],
                    decorators: element['decorators'],
                    visibility: element['visibility'],
                    is_async: element['is_async'],
                    is_deprecated: element['is_deprecated'],
                    source_code: element['source_code']
                };
                element_nodes.append(element_node);
            
            # Create relationship edges
            relationship_edges = [];
            for relationship in relationships:
                relationship_edge = spawn code_relationship {
                    relationship_type: relationship['type'],
                    source_element: relationship['source'],
                    target_element: relationship['target'],
                    line_number: relationship['line'],
                    context: relationship['context'],
                    confidence: relationship['confidence'],
                    is_direct: relationship['is_direct']
                };
                relationship_edges.append(relationship_edge);
            
            report {
                "status": "success",
                "file_path": file_path,
                "language": language,
                "elements_created": len(element_nodes),
                "relationships_created": len(relationship_edges),
                "complexity_score": file_analysis_node.complexity_score
            };
        }
        
        catch Exception as e {
            report {
                "status": "error",
                "file_path": context_vars.get('file_path', 'unknown'),
                "error": str(e)
            };
            disengage;
        }
    }
    
    # Extract code elements from parse tree
    can extract_code_elements(tree_node, language, file_path) -> list {
        elements = [];
        element_counter = 0;
        
        def traverse_tree(node, current_path=""):
            nonlocal element_counter;
            
            # Process based on node type
            if language == "python":
                if node.type == "function_definition":
                    elements.append(extract_python_function(node, file_path, element_counter));
                    element_counter += 1;
                elif node.type == "class_definition":
                    elements.append(extract_python_class(node, file_path, element_counter));
                    element_counter += 1;
                elif node.type == "assignment":
                    elements.append(extract_python_variable(node, file_path, element_counter));
                    element_counter += 1;
            
            elif language == "javascript":
                if node.type == "function_declaration":
                    elements.append(extract_js_function(node, file_path, element_counter));
                    element_counter += 1;
                elif node.type == "class_declaration":
                    elements.append(extract_js_class(node, file_path, element_counter));
                    element_counter += 1;
                elif node.type == "variable_declaration":
                    elements.append(extract_js_variable(node, file_path, element_counter));
                    element_counter += 1;
            
            # Traverse children
            for child in node.children:
                traverse_tree(child, current_path);
        
        traverse_tree(tree_node);
        return elements;
    
    # Extract Python function
    can extract_python_function(node, file_path, element_id) -> dict {
        # Get function name
        name_node = node.child_by_field_name("name");
        function_name = name_node.text.decode() if name_node else "anonymous";
        
        # Get parameters
        params_node = node.child_by_field_name("parameters");
        parameters = [];
        if params_node:
            for param in params_node.children:
                if param.type == "identifier":
                    parameters.append(param.text.decode());
        
        # Get function body for complexity calculation
        body_node = node.child_by_field_name("body");
        complexity = calculate_python_complexity(body_node);
        
        # Get decorators
        decorators = [];
        # Look for decorator nodes (these would be before the function definition)
        
        return {
            "id": f"func_{element_id}_{file_path}",
            "type": "function",
            "name": function_name,
            "start_line": node.start_point[0] + 1,
            "end_line": node.end_point[0] + 1,
            "signature": f"def {function_name}({', '.join(parameters)})",
            "documentation": extract_python_docstring(node),
            "complexity": complexity,
            "dependencies": extract_python_dependencies(node),
            "parameters": parameters,
            "return_type": "Any",  # Python type inference would need more sophisticated analysis
            "decorators": decorators,
            "visibility": "public",
            "is_async": False,  # Would need to check for 'async' keyword
            "is_deprecated": False,
            "source_code": node.text.decode()
        };
    
    # Extract Python class
    can extract_python_class(node, file_path, element_id) -> dict {
        # Get class name
        name_node = node.child_by_field_name("name");
        class_name = name_node.text.decode() if name_node else "anonymous";
        
        # Get base classes
        bases_node = node.child_by_field_name("bases");
        inheritance = [];
        if bases_node:
            for base in bases_node.children:
                if base.type == "identifier":
                    inheritance.append(base.text.decode());
        
        # Calculate complexity
        body_node = node.child_by_field_name("body");
        complexity = calculate_python_complexity(body_node);
        
        return {
            "id": f"class_{element_id}_{file_path}",
            "type": "class",
            "name": class_name,
            "start_line": node.start_point[0] + 1,
            "end_line": node.end_point[0] + 1,
            "signature": f"class {class_name}({', '.join(inheritance)})",
            "documentation": extract_python_docstring(node),
            "complexity": complexity,
            "dependencies": inheritance,
            "parameters": [],  # Class parameters not directly available
            "return_type": "class",
            "decorators": [],  # Would need to extract from class decorators
            "visibility": "public",
            "is_async": False,
            "is_deprecated": False,
            "source_code": node.text.decode()
        };
    
    # Extract Python variable
    can extract_python_variable(node, file_path, element_id) -> dict {
        # Get variable name (simplified)
        targets = node.child_by_field_name("targets");
        var_name = "unknown";
        if targets and targets.children:
            target = targets.children[0];
            if target.type == "identifier":
                var_name = target.text.decode();
        
        return {
            "id": f"var_{element_id}_{file_path}",
            "type": "variable",
            "name": var_name,
            "start_line": node.start_point[0] + 1,
            "end_line": node.end_point[0] + 1,
            "signature": f"{var_name} = ...",
            "documentation": "",
            "complexity": 1.0,
            "dependencies": [],
            "parameters": [],
            "return_type": "Any",
            "decorators": [],
            "visibility": "public",
            "is_async": False,
            "is_deprecated": False,
            "source_code": node.text.decode()
        };
    
    # Extract JavaScript function
    can extract_js_function(node, file_path, element_id) -> dict {
        # Get function name
        name_node = node.child_by_field_name("name");
        function_name = name_node.text.decode() if name_node else "anonymous";
        
        # Get parameters
        params_node = node.child_by_field_name("parameters");
        parameters = [];
        if params_node:
            for param in params_node.children:
                if param.type == "identifier":
                    parameters.append(param.text.decode());
        
        # Calculate complexity
        body_node = node.child_by_field_name("body");
        complexity = calculate_js_complexity(body_node);
        
        return {
            "id": f"func_{element_id}_{file_path}",
            "type": "function",
            "name": function_name,
            "start_line": node.start_point[0] + 1,
            "end_line": node.end_point[0] + 1,
            "signature": f"function {function_name}({', '.join(parameters)})",
            "documentation": extract_js_docstring(node),
            "complexity": complexity,
            "dependencies": extract_js_dependencies(node),
            "parameters": parameters,
            "return_type": "any",
            "decorators": [],
            "visibility": "public",
            "is_async": False,
            "is_deprecated": False,
            "source_code": node.text.decode()
        };
    
    # Extract JavaScript class
    can extract_js_class(node, file_path, element_id) -> dict {
        # Get class name
        name_node = node.child_by_field_name("name");
        class_name = name_node.text.decode() if name_node else "anonymous";
        
        return {
            "id": f"class_{element_id}_{file_path}",
            "type": "class",
            "name": class_name,
            "start_line": node.start_point[0] + 1,
            "end_line": node.end_point[0] + 1,
            "signature": f"class {class_name}",
            "documentation": extract_js_docstring(node),
            "complexity": 1.0,
            "dependencies": [],
            "parameters": [],
            "return_type": "class",
            "decorators": [],
            "visibility": "public",
            "is_async": False,
            "is_deprecated": False,
            "source_code": node.text.decode()
        };
    
    # Extract JavaScript variable
    can extract_js_variable(node, file_path, element_id) -> dict {
        # Get variable name (simplified)
        declarations = node.child_by_field_name("declarations");
        var_name = "unknown";
        if declarations and declarations.children:
            declarator = declarations.children[0];
            name_node = declarator.child_by_field_name("name");
            if name_node:
                var_name = name_node.text.decode();
        
        return {
            "id": f"var_{element_id}_{file_path}",
            "type": "variable",
            "name": var_name,
            "start_line": node.start_point[0] + 1,
            "end_line": node.end_point[0] + 1,
            "signature": f"let {var_name} = ...",
            "documentation": "",
            "complexity": 1.0,
            "dependencies": [],
            "parameters": [],
            "return_type": "any",
            "decorators": [],
            "visibility": "public",
            "is_async": False,
            "is_deprecated": False,
            "source_code": node.text.decode()
        };
    
    # Extract relationships from parse tree
    can extract_relationships(tree_node, language, file_path) -> list {
        relationships = [];
        
        def traverse_for_relationships(node, current_element=None):
            if language == "python":
                if node.type == "call":
                    # Function call relationship
                    func_name = extract_call_name(node);
                    if func_name:
                        relationships.append({
                            "type": "calls",
                            "source": current_element,
                            "target": func_name,
                            "line": node.start_point[0] + 1,
                            "context": node.text.decode(),
                            "confidence": 0.8,
                            "is_direct": True
                        });
                elif node.type == "import_from_statement":
                    # Import relationship
                    module_name = extract_import_module(node);
                    if module_name:
                        relationships.append({
                            "type": "imports",
                            "source": file_path,
                            "target": module_name,
                            "line": node.start_point[0] + 1,
                            "context": node.text.decode(),
                            "confidence": 0.9,
                            "is_direct": True
                        });
                elif node.type == "attribute":
                    # Attribute access relationship
                    attr_name = extract_attribute_name(node);
                    if attr_name and current_element:
                        relationships.append({
                            "type": "uses",
                            "source": current_element,
                            "target": attr_name,
                            "line": node.start_point[0] + 1,
                            "context": node.text.decode(),
                            "confidence": 0.7,
                            "is_direct": True
                        });
            
            elif language == "javascript":
                if node.type == "call_expression":
                    # Function call relationship
                    func_name = extract_js_call_name(node);
                    if func_name:
                        relationships.append({
                            "type": "calls",
                            "source": current_element,
                            "target": func_name,
                            "line": node.start_point[0] + 1,
                            "context": node.text.decode(),
                            "confidence": 0.8,
                            "is_direct": True
                        });
                elif node.type == "import_statement":
                    # Import relationship
                    module_name = extract_js_import_module(node);
                    if module_name:
                        relationships.append({
                            "type": "imports",
                            "source": file_path,
                            "target": module_name,
                            "line": node.start_point[0] + 1,
                            "context": node.text.decode(),
                            "confidence": 0.9,
                            "is_direct": True
                        });
            
            # Continue traversal
            for child in node.children:
                traverse_for_relationships(child, current_element);
        
        traverse_for_relationships(tree_node);
        return relationships;
    
    # Helper functions for extracting information
    can extract_python_docstring(node) -> str {
        # Look for docstring in function/class body
        body_node = node.child_by_field_name("body");
        if body_node and body_node.children:
            first_stmt = body_node.children[0];
            if first_stmt.type == "expression_statement":
                expr = first_stmt.child(0);
                if expr.type == "string":
                    return expr.text.decode();
        return "";
    }
    
    can extract_python_dependencies(node) -> list {
        # Extract function call dependencies
        dependencies = [];
        
        def find_calls(node):
            if node.type == "call":
                func_name = extract_call_name(node);
                if func_name:
                    dependencies.append(func_name);
            
            for child in node.children:
                find_calls(child);
        
        find_calls(node);
        return list(set(dependencies));  # Remove duplicates
    }
    
    can extract_call_name(node) -> str {
        # Extract function call name
        func_node = node.child(0);
        if func_node.type == "attribute":
            # method call: obj.method
            return f"{func_node.child(0).text.decode()}.{func_node.child(1).text.decode()}";
        elif func_node.type == "identifier":
            # simple call: function()
            return func_node.text.decode();
        return "";
    }
    
    can extract_import_module(node) -> str {
        # Extract module name from import statement
        if node.child(0).type == "dotted_name":
            return node.child(0).text.decode();
        elif node.child(0).type == "identifier":
            return node.child(0).text.decode();
        return "";
    }
    
    can extract_attribute_name(node) -> str {
        # Extract attribute name
        if node.child(1).type == "identifier":
            return node.child(1).text.decode();
        return "";
    }
    
    # JavaScript helper functions
    can extract_js_docstring(node) -> str {
        # Look for JSDoc comments
        return "";  # Simplified for now
    }
    
    can extract_js_dependencies(node) -> list {
        dependencies = [];
        
        def find_js_calls(node):
            if node.type == "call_expression":
                func_name = extract_js_call_name(node);
                if func_name:
                    dependencies.append(func_name);
            
            for child in node.children:
                find_js_calls(child);
        
        find_js_calls(node);
        return list(set(dependencies));
    }
    
    can extract_js_call_name(node) -> str {
        # Extract JavaScript function call name
        callee = node.child_by_field_name("function");
        if callee:
            return callee.text.decode();
        return "";
    }
    
    can extract_js_import_module(node) -> str {
        # Extract module name from import statement
        source_node = node.child_by_field_name("source");
        if source_node:
            return source_node.text.decode().strip('"').strip("'");
        return "";
    }
    
    # Complexity calculation functions
    can calculate_python_complexity(node) -> float {
        if not node:
            return 1.0;
        
        complexity = 1.0;
        
        def count_complexity_constructs(node):
            nonlocal complexity;
            
            # Count various complexity-inducing constructs
            if node.type in ["if_statement", "for_statement", "while_statement", "try_statement"]:
                complexity += 1;
            elif node.type == "elif_clause":
                complexity += 0.5;
            elif node.type == "except_clause":
                complexity += 1;
            elif node.type in ["and_expression", "or_expression"]:
                complexity += 1;
            
            for child in node.children:
                count_complexity_constructs(child);
        
        count_complexity_constructs(node);
        return complexity;
    }
    
    can calculate_js_complexity(node) -> float {
        if not node:
            return 1.0;
        
        complexity = 1.0;
        
        def count_js_complexity(node):
            nonlocal complexity;
            
            if node.type in ["if_statement", "for_statement", "while_statement", "switch_statement"]:
                complexity += 1;
            elif node.type == "case_clause":
                complexity += 0.5;
            elif node.type in ["binary_expression", "logical_expression"]:
                complexity += 1;
            
            for child in node.children:
                count_js_complexity(child);
        
        count_js_complexity(node);
        return complexity;
    }
    
    can calculate_complexity_score(tree_root) -> float {
        if not tree_root:
            return 0.0;
        
        # Calculate overall file complexity
        total_complexity = 0.0;
        element_count = 0;
        
        def analyze_node(node):
            nonlocal total_complexity, element_count;
            
            if node.type in ["function_definition", "class_definition", "method_definition"]:
                element_count += 1;
                if node.type == "function_definition":
                    total_complexity += calculate_python_complexity(node.child_by_field_name("body"));
                elif node.type == "class_definition":
                    total_complexity += calculate_python_complexity(node.child_by_field_name("body"));
            
            for child in node.children:
                analyze_node(child);
        
        analyze_node(tree_root);
        return total_complexity / max(element_count, 1);
    }
    
    # Build module hierarchy
    can build_module_hierarchy with entry {
        try {
            import: py from pathlib;
            
            modules = {};
            repository_path = context_vars['repository_path'];
            
            def process_directory(dir_path, current_module=""):
                for item in pathlib.Path(dir_path).iterdir():
                    if item.is_file() and item.suffix in [".py", ".js", ".ts", ".java", ".cpp", ".c"]:
                        # Create module for file
                        module_name = item.stem;
                        full_module_path = str(item.relative_to(repository_path));
                        
                        if current_module:
                            module_name = f"{current_module}.{module_name}";
                        
                        if module_name not in modules:
                            modules[module_name] = {
                                "name": module_name,
                                "path": full_module_path,
                                "is_package": False,
                                "level": module_name.count("."),
                                "parent": current_module if "." in module_name else None,
                                "children": []
                            };
                        
                        # Add to parent module's children
                        if current_module and current_module in modules:
                            modules[current_module]["children"].append(module_name);
                    
                    elif item.is_dir() and item.name not in [".git", "__pycache__", "node_modules"]:
                        # Process subdirectory
                        sub_module = f"{current_module}.{item.name}" if current_module else item.name;
                        process_directory(item, sub_module);
            
            process_directory(repository_path);
            
            # Create module nodes
            module_nodes = [];
            for module_name, module_info in modules.items():
                module_node = spawn module {
                    module_name: module_name,
                    module_path: module_info["path"],
                    is_package: len(module_info["children"]) > 0,
                    imports: [],
                    exports: [],
                    dependencies: [],
                    level: module_info["level"],
                    parent_module: module_info["parent"],
                    submodules: module_info["children"]
                };
                module_nodes.append(module_node);
            
            report {
                "status": "success",
                "modules_created": len(module_nodes),
                "module_hierarchy": modules
            };
        }
        
        catch Exception as e {
            report {
                "status": "error",
                "error": f"Module hierarchy construction failed: {str(e)}"
            };
            disengage;
        }
    }
    
    # Calculate repository metrics
    can calculate_repository_metrics with entry {
        try {
            # Collect all elements and relationships
            all_elements = [];
            all_relationships = [];
            language_stats = {};
            
            # This would typically query the graph database or nodes created earlier
            # For now, return a basic structure
            
            metrics = {
                "total_files": 0,
                "total_elements": 0,
                "total_relationships": 0,
                "complexity_distribution": {},
                "language_distribution": {},
                "dependency_metrics": {
                    "circular_dependencies": [],
                    "orphaned_modules": [],
                    "core_modules": []
                },
                "quality_metrics": {
                    "avg_complexity": 0.0,
                    "max_complexity": 0.0,
                    "documentation_coverage": 0.0,
                    "test_coverage": 0.0
                }
            };
            
            report {
                "status": "success",
                "metrics": metrics
            };
        }
        
        catch Exception as e {
            report {
                "status": "error",
                "error": f"Metrics calculation failed: {str(e)}"
            };
            disengage;
        }
    }
    
    # Main analysis workflow
    with entry {
        report {"step": "starting", "message": "Repository analysis process initiated"};
        
        # Step 1: Initialize parsers
        parser_result = spawn initialize_parsers;
        if parser_result["status"] == "error":
            report {"error": "Parser initialization failed", "details": parser_result["error"]};
            disengage;
        
        report {"step": "initialized", "message": "Language parsers initialized"};
        
        # Step 2: Build module hierarchy
        module_result = spawn build_module_hierarchy;
        if module_result["status"] == "error":
            report {"error": "Module hierarchy construction failed", "details": module_result["error"]};
            disengage;
        
        report {"step": "modules", "message": "Module hierarchy constructed"};
        
        # Step 3: Parse and analyze files (this would iterate through files from Repository Mapper)
        # For now, we'll create a placeholder for the file processing logic
        
        # Step 4: Calculate metrics
        metrics_result = spawn calculate_repository_metrics;
        if metrics_result["status"] == "error":
            report {"error": "Metrics calculation failed", "details": metrics_result["error"]};
            disengage;
        
        report {"step": "completed", "message": "Repository analysis completed"};
        
        # Return comprehensive results
        final_result = {
            "status": "success",
            "repository_path": repository_path,
            "parser_initialization": parser_result,
            "module_hierarchy": module_result,
            "metrics": metrics_result["metrics"],
            "analysis_complete": true,
            "timestamp": str(datetime.datetime.now())
        };
        
        report final_result;
    }
}

# HTTP API Walker for Code Analysis
walker api_analyze_repository {
    has repository_path: str;
    has max_file_size: int = 10485760;
    has include_ignored: bool = false;
    has analysis_depth: str = "full";
    
    with entry {
        result = spawn analyze_repository {
            repository_path: repository_path,
            max_file_size: max_file_size,
            include_ignored: include_ignored,
            analysis_depth: analysis_depth
        };
        
        report result;
    }
}

# Query API for Code Relationships
walker query_code_relationships {
    has repository_path: str;
    has query_type: str;  # 'dependencies', 'dependents', 'call_graph', 'inheritance'
    has element_name: str = "";
    has element_type: str = "";
    has max_results: int = 100;
    
    with entry {
        try {
            # Query relationships based on type
            if query_type == "dependencies":
                # Find what this element depends on
                result = {
                    "query_type": "dependencies",
                    "element_name": element_name,
                    "dependencies": [],  # Would query actual graph
                    "confidence_threshold": 0.7
                };
            elif query_type == "dependents":
                # Find what depends on this element
                result = {
                    "query_type": "dependents",
                    "element_name": element_name,
                    "dependents": [],  # Would query actual graph
                    "confidence_threshold": 0.7
                };
            elif query_type == "call_graph":
                # Build call graph for a function/class
                result = {
                    "query_type": "call_graph",
                    "element_name": element_name,
                    "callers": [],  # Would query actual graph
                    "callees": [],  # Would query actual graph
                    "complexity": 0.0
                };
            elif query_type == "inheritance":
                # Find inheritance relationships
                result = {
                    "query_type": "inheritance",
                    "element_name": element_name,
                    "superclasses": [],  # Would query actual graph
                    "subclasses": [],  # Would query actual graph
                    "depth": 0
                };
            else:
                report {"error": f"Unknown query type: {query_type}"};
                disengage;
            
            report {
                "status": "success",
                "query_result": result,
                "repository_path": repository_path,
                "timestamp": str(datetime.datetime.now())
            };
        }
        
        catch Exception as e {
            report {
                "status": "error",
                "error": f"Query execution failed: {str(e)}"
            };
            disengage;
        }
    }
}

# Test walker for validation
walker test_code_analysis {
    has test_path: str = "/tmp/test_repo";
    
    with entry {
        report {"message": "Testing code analysis with sample repository"};
        
        # Create a simple test repository
        import: py from pathlib;
        test_repo = pathlib.Path(test_path);
        test_repo.mkdir(exist_ok=True);
        
        # Create a simple Python file for testing
        test_file = test_repo / "test.py";
        test_content = '''
def hello_world():
    """A simple function"""
    print("Hello, World!")
    return "Hello"

class TestClass:
    """A simple test class"""
    
    def __init__(self):
        self.name = "test"
    
    def method(self):
        return hello_world()
        ''';
        
        test_file.write_text(test_content);
        
        result = spawn api_analyze_repository {
            repository_path: str(test_repo),
            analysis_depth: "basic"
        };
        
        # Clean up
        import shutil;
        shutil.rmtree(test_repo);
        
        report {
            "test_result": result,
            "status": "completed" if result.get("status") == "success" else "failed"
        };
    }
}

# Health check walker
walker code_analysis_health_check {
    with entry {
        report {
            "service": "Code Analyzer Agent",
            "status": "healthy",
            "timestamp": str(datetime.datetime.now()),
            "version": "1.0.0",
            "supported_languages": ["python", "javascript", "typescript", "java", "cpp", "c"],
            "endpoints": [
                "/api/analyze-repository",
                "/api/query-relationships",
                "/api/test-analysis",
                "/api/health"
            ]
        };
    }
}